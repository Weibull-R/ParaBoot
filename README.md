ParaBoot
========

 

Parametric bootstrap bounds for Weibull and Lognormal models.

 

Parametric bootstrapping has also been referenced as pivotal analysis. Robert
Abernethy promoted the pivotal bounds based on median rank regression models in
his "The New Weibull Handbook". Abernethy also invested much effort in
establishing a goodness of fit measure on the basis of the percent of r and
r-squared, prr, derived from the pivotal analysis.

Pivotal analysis has also been discussed in Jerome Lawless’ book “ “. The
analysis he describes is based on maximum likelihood estimation models and is
perhaps the most foundational writing on the topic.

 

### Complete Failure Data, Weibull Sampling

In the simplest case a pivotal analysis is demonstrated in code for data
containing 20 complete failure points. It is expected that one would produce a
pivotal analysis sampling on Weibull parameters of Beta = 1 and Eta = 1.  In the
example script complete2p.r only 20 samples are drawn to make the plot sensible,
but this is not enough to represent the full spectrum generated by say 10,000
samples; the default used in WeibullR.

As the parametric bootstrap is carried out the quantiles for each fitted sample
at designated descriptive percentiles are accumulated as rows in a matrix. When
each percentile column is sorted the rows describe confidence bounds.
Importantly with complete failure samples the median line defines a unity where
Eta and Beta \~= 1. I will refer to this as the unity bootstrap for rest of this
discussion.

For any example data for which confidence bounds are to be formed it is possible
to take the unity bootstrap and translate for given log(Eta), then rotate, with
y as `log(log(1/(1-unreliabiilty)`, for given Beta. Rotation is centered at the
63.2% “characteristic life” point `pweibull(1,1,1)`.

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# complete2p.r
library(WeibullR)
S<-20
CI<-.8
n=20
set.seed(654321)
unity_pts<-qweibull(getPPP(rweibull(n,1,1))$ppp,1,1)
obj_list<-list()
for(x in 1:S) {
    sample\<-rweibull(n,1,1)
    obj_list[[x]]<-wblr(sample, col="transparent")
    obj_list[[x]]<-wblr.fit(obj_list[[x]], col="gray", lwd=.1)
}
# graphic presentation
obj<-wblr(unity_pts, col="transparent")
obj<-wblr.fit(obj, col="black")
obj<-wblr.conf(obj, ci=CI, lty="dashed", lwd=2, col="red")
obj_list[[S+1]]<-obj
plot.wblr(obj_list, is.plot.legend=FALSE, main="Pivotal Analysis of Complete Failures" )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\<\<\<\<\<\<\< HEAD  

### Failure Data with Censoring, Weibull Sampling

The co-author of WeibullR, Jurgen Symynck, was fascinated by the pivotal
analysis and its application on an extreme example with only 3 complete failures
and 10 type 2 suspended data points. As one attempts the parametric bootstrap on
such mixed data (failure and censoring) it is notorious that the median line
seems to wander inexplicably. What Jurgen accidentally found was that if he
generated pivotal points in similar fashion to the unity points described above,
the fitted parameters of those points, without suspensions, became pleasing
parameters to use for the bootstrap. Pleasing because the median produced by a
large number of parametric bootstrap samples describes a line reasonably close
to the unity line.  This is important because it is desirable to have a uniform
basis for translation and rotation to example data parameters

It is noted that pivotal points, when distributed according to the percentile
plotting positions of the original data produce a unity line. This is exactly
how they were generated.

Script Jurgen2p.r implements the extreme example with type 2 censored values.
Script arbcens2p.r implements a case where example data would contain
arbitrarily positioned censored values. In both cases the pivotal points are
displayed in their unity line, which is shown to match the bootstrap median.

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Jurgen2p.r
library(WeibullR)
S\<-20
CI\<-.8
nf=3
ns=10
set.seed(1234)
fail_pts\<-rweibull(nf,1,1)
median_ranks\<-getPPP(x=fail_pts, s=rep(10,ns))\$ppp
pivotal_pts\<-qweibull(median_ranks,1,1)
par\<-lslr(getPPP(pivotal_pts))
obj_list\<-list()
for(x in 1:S) {
    sample\<-rweibull(nf,par[2],par[1])
    obj_list[[x]]\<-wblr(x=sample, s=rep(10,ns), col="transparent")
    obj_list[[x]]\<-wblr.fit(obj_list[[x]], col="gray", lwd=.1)
}
\# Back end function pivotal.rr can be used to identify the median from a
\# parametric bootsrap of 10,000 samples
\# dp\<-sort(c(getPPP(rweibull(6,1,1))\$ppp, pweibull(1,1,1)))
\# bounds\<-pivotal.rr(getPPP(fail_pts, rep(10,ns)), R2=0.0, CI=1.0, P1=par[1],
P2=par[2],unrel=dp)
\# median\<-bounds[5000,]
\# graphic presentation
\# Pivotal points, when distributed according to the percentile
\# plotting positions of the original data produce a unity line
obj\<-wblr(x=pivotal_pts, s=rep(10,ns), col="black")
obj\<-wblr.fit(obj, col="transparent")
obj\<-wblr.conf(obj, ci=CI, lty="dashed", lwd=2, col="red")
obj_list[[S+1]]\<-obj
plot.wblr(obj_list, is.plot.legend=FALSE, main="Pivotal Analysis of Failure Data
with Type 2 Censored Values" )
\# points(exp(median), p2y(dp), col="blue")
#
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#abcens2p.r

\# this function is required to fill in censored event times in the unity_TEDF					
unity_TEDF\<- function(pivotal_pts, event_vec) {					
	time_vec\<-NULL				
	piv_num\<-1				
	for(ev in 1:length(event_vec)) {				
		if(event_vec[ev] == 1) {			
			time_vec \<- c(time_vec, pivotal_pts[piv_num])		
			piv_num \<- piv_num + 1		
		}else{			
			if(piv_num \> 1 && piv_num\<length(pivotal_pts)+1) {		
				midtime\<-sum(pivotal_pts[(piv_num-1):piv_num])/2	
				time_vec \<- c(time_vec, midtime)	
			}		
			if(piv_num == 1 ) {		
				midtime\<- pivotal_pts[1]/2	
				time_vec \<- c(time_vec, midtime)	
			}		
			if(piv_num \>length(pivotal_pts) )  {		
				endtime\<-max(pivotal_pts) + 10	
				time_vec \<- c(time_vec, endtime)	
			}
		}
	}				
	return(data.frame(time=time_vec, event=event_vec))				
}					


library(WeibullR)	
S\<-20	
CI\<-.8	
nf=20	
ns=5	
set.seed(4321)
example_data\<-rweibull(nf+ns, 1,1)	
example_TEDF\<-data.frame(time=example_data, event=c(rep(1,nf), rep(0,ns)))	
NDX\<-order(example_data)	
example_TEDF\<-example_TEDF[NDX,]	
event_vec\<-example_TEDF\$event	
median_ranks\<-getPPP(example_TEDF)\$ppp
pivotal_pts\<-qweibull(median_ranks,1,1)
par\<-lslr(getPPP(pivotal_pts))
obj_list\<-list()
for(x in 1:S) {		
	sample\<-rweibull((nf+ns),par[2],par[1])	
	sample_TEDF\<-data.frame(time=sort(sample), event=event_vec)	
	obj_list[[x]]\<-wblr(sample_TEDF, col="transparent")	
	obj_list[[x]]\<-wblr.fit(obj_list[[x]], col="gray", lwd=.1)	
}
\# graphic presentation
\# Pivotal points, when distributed according to the percentile
\# plotting positions of the original data produce a unity line
obj\<-wblr(unity_TEDF(pivotal_pts, event_vec), col="transparent")
obj\<-wblr.fit(obj, col="transparent")
obj\<-wblr.conf(obj, ci=CI, lty="dashed", lwd=2, col="red")
obj_list[[S+1]]\<-obj
plot.wblr(obj_list, is.plot.legend=FALSE, main="Pivotal Analysis of Failure Data
with Arbitrarily Censored Values" )
\# Back end function pivotal.rr can be used to identify the median
\# (and any confidence interval bounds)
\# from a parametric bootsrap of 10,000 samples
dp\<-c(.001,median_ranks,pweibull(1,1,1),.999)
bounds\<-pivotal.rr(getPPP(example_TEDF), R2=0.0, CI=1.0, P1=par[1],
P2=par[2],unrel=dp)
boot_median\<-bounds[5000,]
\# display the boot median as a line with its eta point blue)
points(exp(boot_median), p2y(dp), type="l",col="blue")
points(exp(boot_median[which(dp==pweibull(1,1,1))]),
p2y(dp[which(dp==pweibull(1,1,1))]), col="blue")
\# since the pivotal points in the wblr object were set to "transparent"
\# here is an optional way to show the pivotal points in unity order
points(pivotal_pts, p2y(median_ranks), lwd=2, col="forestgreen")
\# prove the unity line
unity_fit\<-lslr(getPPP(unity_TEDF(pivotal_pts, event_vec)))
unity_fit
\# get the weibull parameters for the boot_median
median_eta\<-exp(boot_median[which(dp==pweibull(1,1,1))])
rise\<-p2y(max(dp))-p2y(min(dp))
run\<-max(boot_median)-min(boot_median)
median_beta\<-rise/run
print(paste0("median eta:  ",median_eta))
print(paste0("median beta:  ",median_beta))
#
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
