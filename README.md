ParaBoot
========

 

Parametric bootstrap bounds for Weibull and Lognormal models.

 

Parametric bootstrapping has also been referenced as pivotal analysis. Robert
Abernethy promoted the pivotal bounds based on median rank regression models in
his "The New Weibull Handbook". Abernethy also invested much effort in
establishing a goodness of fit measure on the basis of the percent of r and
r-squared, prr, derived from the pivotal analysis.

Pivotal analysis has also been discussed in Jerome Lawless’ book “ “. The
analysis he describes is based on maximum likelihood estimation models and is
perhaps the most foundational writing on the topic.

 

### Complete Failure Data, Weibull Sampling

In the simplest case a pivotal analysis is demonstrated in code for data
containing 20 complete failure points. It is expected that one would produce a
pivotal analysis sampling on Weibull parameters of Beta = 1 and Eta = 1.  In the
example script complete2p.r only 20 samples are drawn to make the plot sensible,
but this is not enough to represent the full spectrum generated by say 10,000
samples; the default used in WeibullR.

As the parametric bootstrap is carried out the quantiles for each fitted sample
at designated descriptive percentiles are accumulated as rows in a matrix. When
each percentile column is sorted the rows describe confidence bounds.
Importantly with complete failure samples the median line defines a unity where
Eta and Beta \~= 1. I will refer to this as the unity bootstrap for rest of this
discussion.

For any example data for which confidence bounds are to be formed it is possible
to take the unity bootstrap and translate for given log(Eta), then rotate, with
y as `log(log(1/(1-unreliabiilty)`, for given Beta. Rotation is centered at the
63.2% “characteristic life” point `pweibull(1,1,1)`.

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# complete2p.r
library(WeibullR)
S<-20
CI<-.8
n=20
set.seed(654321)
unity_pts<-qweibull(getPPP(rweibull(n,1,1))$ppp,1,1)
obj_list<-list()
for(x in 1:S) {
    sample\<-rweibull(n,1,1)
    obj_list[[x]]<-wblr(sample, col="transparent")
    obj_list[[x]]<-wblr.fit(obj_list[[x]], col="gray", lwd=.1)
}
# graphic presentation
obj<-wblr(unity_pts, col="transparent")
obj<-wblr.fit(obj, col="black")
obj<-wblr.conf(obj, ci=CI, lty="dashed", lwd=2, col="red")
obj_list[[S+1]]<-obj
plot.wblr(obj_list, is.plot.legend=FALSE, main="Pivotal Analysis of Complete Failures" )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### Failure Data with Censoring, Weibull Sampling

The co-author of WeibullR, Jurgen Symynck, was fascinated by the pivotal
analysis and its application on an extreme example with only 3 complete failures
and 10 type 2 suspended data points. As one attempts the parametric bootstrap on
such mixed data (failure and censoring) it is notorious that the median line
seems to wander inexplicably. What Jurgen accidentally found was that if he
generated pivotal points in similar fashion to the unity points described above,
the fitted parameters of those points, without suspensions, became pleasing
parameters to use for the bootstrap. Pleasing because the median produced by a
large number of parametric bootstrap samples describes a line reasonably close
to the unity line.  This is important because it is desirable to have a uniform
basis for translation and rotation to example data parameters

It is noted that pivotal points, when distributed according to the percentile
plotting positions of the original data produce a unity line. This is exactly
how they were generated.

Script Jurgen2p.r implements the extreme example with type 2 censored values.
Script arbcens2p.r implements a case where example data would contain
arbitrarily positioned censored values. In both cases the pivotal points are
displayed in their unity line, which is shown to match the bootstrap median.

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Jurgen2p.r
library(WeibullR)
S\<-20
CI\<-.8
nf=3
ns=10
set.seed(1234)
fail_pts\<-rweibull(nf,1,1)
median_ranks\<-getPPP(x=fail_pts, s=rep(10,ns))\$ppp
pivotal_pts\<-qweibull(median_ranks,1,1)
par\<-lslr(getPPP(pivotal_pts))
obj_list\<-list()
for(x in 1:S) {
    sample\<-rweibull(nf,par[2],par[1])
    obj_list[[x]]\<-wblr(x=sample, s=rep(10,ns), col="transparent")
    obj_list[[x]]\<-wblr.fit(obj_list[[x]], col="gray", lwd=.1)
}
\# Back end function pivotal.rr can be used to identify the median from a
\# parametric bootsrap of 10,000 samples
\# dp\<-sort(c(getPPP(rweibull(6,1,1))\$ppp, pweibull(1,1,1)))
\# bounds\<-pivotal.rr(getPPP(fail_pts, rep(10,ns)), R2=0.0, CI=1.0, P1=par[1],
P2=par[2],unrel=dp)
\# median\<-bounds[5000,]
\# graphic presentation
\# Pivotal points, when distributed according to the percentile
\# plotting positions of the original data produce a unity line
obj\<-wblr(x=pivotal_pts, s=rep(10,ns), col="black")
obj\<-wblr.fit(obj, col="transparent")
obj\<-wblr.conf(obj, ci=CI, lty="dashed", lwd=2, col="red")
obj_list[[S+1]]\<-obj
plot.wblr(obj_list, is.plot.legend=FALSE, main="Pivotal Analysis of Failure Data
with Type 2 Censored Values" )
\# points(exp(median), p2y(dp), col="blue")
#
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#abcens2p.r

\# this function is required to fill in censored event times in the unity_TEDF                  unity_TEDF\<- function(pivotal_pts, event_vec) {                    
    time_vec\<-NULL             
    piv_num\<-1             
    for(ev in 1:length(event_vec)) {                
        if(event_vec[ev] == 1) {            
            time_vec \<- c(time_vec, pivotal_pts[piv_num])      
            piv_num \<- piv_num + 1     
        }else{          
            if(piv_num \> 1 && piv_num\<length(pivotal_pts)+1) {        
                midtime\<-sum(pivotal_pts[(piv_num-1):piv_num])/2   
                time_vec \<- c(time_vec, midtime)   
            }       
            if(piv_num == 1 ) {     
                midtime\<- pivotal_pts[1]/2 
                time_vec \<- c(time_vec, midtime)   
            }       
            if(piv_num \>length(pivotal_pts) )  {       
                endtime\<-max(pivotal_pts) + 10 
                time_vec \<- c(time_vec, endtime)   
            }
        }
    }               
    return(data.frame(time=time_vec, event=event_vec))              
}                   


library(WeibullR)   
S\<-20  
CI\<-.8 
nf=20   
ns=5    
set.seed(4321)
example_data\<-rweibull(nf+ns, 1,1) 
example_TEDF\<-data.frame(time=example_data, event=c(rep(1,nf), rep(0,ns))) 
NDX\<-order(example_data)   
example_TEDF\<-example_TEDF[NDX,]   
event_vec\<-example_TEDF\$event 
median_ranks\<-getPPP(example_TEDF)\$ppp
pivotal_pts\<-qweibull(median_ranks,1,1)
par\<-lslr(getPPP(pivotal_pts))
obj_list\<-list()
for(x in 1:S) {     
    sample\<-rweibull((nf+ns),par[2],par[1])    
    sample_TEDF\<-data.frame(time=sort(sample), event=event_vec)    
    obj_list[[x]]\<-wblr(sample_TEDF, col="transparent")    
    obj_list[[x]]\<-wblr.fit(obj_list[[x]], col="gray", lwd=.1) 
}
\# graphic presentation
\# Pivotal points, when distributed according to the percentile
\# plotting positions of the original data produce a unity line
obj\<-wblr(unity_TEDF(pivotal_pts, event_vec), col="transparent")
obj\<-wblr.fit(obj, col="transparent")
obj\<-wblr.conf(obj, ci=CI, lty="dashed", lwd=2, col="red")
obj_list[[S+1]]\<-obj
plot.wblr(obj_list, is.plot.legend=FALSE, main="Pivotal Analysis of Failure Data
with Arbitrarily Censored Values" )
\# Back end function pivotal.rr can be used to identify the median
\# (and any confidence interval bounds)
\# from a parametric bootsrap of 10,000 samples
dp\<-c(.001,median_ranks,pweibull(1,1,1),.999)
bounds\<-pivotal.rr(getPPP(example_TEDF), R2=0.0, CI=1.0, P1=par[1],
P2=par[2],unrel=dp)
boot_median\<-bounds[5000,]
\# display the boot median as a line with its eta point blue)
points(exp(boot_median), p2y(dp), type="l",col="blue")
points(exp(boot_median[which(dp==pweibull(1,1,1))]),
p2y(dp[which(dp==pweibull(1,1,1))]), col="blue")
\# since the pivotal points in the wblr object were set to "transparent"
\# here is an optional way to show the pivotal points in unity order
points(pivotal_pts, p2y(median_ranks), lwd=2, col="forestgreen")
\# prove the unity line
unity_fit\<-lslr(getPPP(unity_TEDF(pivotal_pts, event_vec)))
unity_fit
\# get the weibull parameters for the boot_median
median_eta\<-exp(boot_median[which(dp==pweibull(1,1,1))])
rise\<-p2y(max(dp))-p2y(min(dp))
run\<-max(boot_median)-min(boot_median)
median_beta\<-rise/run
print(paste0("median eta:  ",median_eta))
print(paste0("median beta:  ",median_beta))
#
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### Bootstrapping with Three Parameters

Previous work on bootstrapping with data fitted to three parameters was included
in the WeibullR source code for version 1.0.12 in a file pivotal3pw.r dated
3/26/2019 (almost 2 years ago as of this writing). As had been common through
previous implementations in WeibullR the bootstrap median was the focus of
attention and the basis for translation and rotation. In that work performed on
complete failure samples only the third parameter, t0, from the fitted example
was used in the bootstrap sampling. This required exclusion of some samples that
produced negative time values.

The method of bootstrapping used in that test code generated pleasing bootstrap
bounds with the median closely matching the unity line. However, when applied to
data examples including censoring the bootstrap median was found to vary wildly.
This stopped development which was not continued until preparing this writing.

The method used to generate the 2-parameter, arbitrarily censored example
script, arbcens2p.r, was found to provide a good model expandable to the
3-parameter case. The methodology is to generate the bootstrap samples on the
2-parameter basis, these are then fitted to the 3-parameter model. This method
provides a pleasingly consistent method to carry from complete failure cases
through all types of censoring. For all bound translation and rotation needs the
unity line defined by the pivotal points in the plotting positions determined by
the example data will be the basis.

The script arbcens3p examples this methodology and can be shown applicable to
complete failure data by setting the ns to zero. This will now be the basis for
3p pivotal bound development for WeibullR.

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#abcens3p.r

\# this function is required to fill in censored event times in the unity_TEDF					
unity_TEDF\<- function(pivotal_pts, event_vec) {	
	time_vec\<-NULL	
	piv_num\<-1	
	for(ev in 1:length(event_vec)) {
		if(event_vec[ev] == 1) {
			time_vec \<- c(time_vec, pivotal_pts[piv_num])		
			piv_num \<- piv_num + 1		
		}else{			
			if(piv_num \> 1 && piv_num\<length(pivotal_pts)+1) {		
				midtime\<-sum(pivotal_pts[(piv_num-1):piv_num])/2	
				time_vec \<- c(time_vec, midtime)	
			}	
			if(piv_num == 1 ) {	
				midtime\<- pivotal_pts[1]/2	
				time_vec \<- c(time_vec, midtime)
			}	
			if(piv_num \>length(pivotal_pts) )  {	
				endtime\<-max(pivotal_pts) + 10	
				time_vec \<- c(time_vec, endtime)	
			}
		}
	}
	return(data.frame(time=time_vec, event=event_vec))				
}					

 

library(WeibullR)		
Sg\<-20	
Sb\<-1000	
CI\<-.8	
nf=20	
ns=5	
set.seed(4321)		
example_data\<-rweibull(nf+ns, 1,1)	
example_TEDF\<-data.frame(time=example_data, event=c(rep(1,nf), rep(0,ns)))	
NDX\<-order(example_data)	
example_TEDF\<-example_TEDF[NDX,]	
event_vec\<-example_TEDF\$event	
median_ranks\<-getPPP(example_TEDF)\$ppp	
pivotal_pts\<-qweibull(median_ranks,1,1)	
par\<-lslr(getPPP(pivotal_pts))	
obj_list\<-list()
for(x in 1:Sg) {
	sample\<-rweibull((nf+ns),par[2],par[1])
	sample_TEDF\<-data.frame(time=sort(sample), event=event_vec)
	obj_list[[x]]\<-wblr(sample_TEDF, col="transparent")
	obj_list[[x]]\<-wblr.fit(obj_list[[x]], dist="weibull3p", col="gray", lwd=.1)
}		
\# descriptive percentiles	
dp\<-c(.001,.01, .02, .05, .10, .15, .20, .30, .40, .50,  .60, .70, .80, .90,
.95, .99,.999)
boot.mat\<-NULL	
for(x in 1:Sb) {
	sample\<-rweibull((nf+ns),par[2],par[1])
	sample_TEDF\<-data.frame(time=sort(sample), event=event_vec)
	fit\<-lslr(getPPP(sample_TEDF), npar=3)
	xvals\<- qweibull(dp,fit[2], fit[1])+fit[3]
	boot.mat\<-rbind(boot.mat, xvals)
}
boot.mat\<-apply(boot.mat,2,sort)
lo_row\<-ceiling(Sb\*(1-CI)/2)
up_row\<-floor(Sb\*(1-(1-CI)/2))
Lower\<-boot.mat[lo_row,]
Lower\<-sapply(Lower,function(X) ifelse(X\<=0,NA,X))
Upper\<-boot.mat[up_row,]
Median\<-boot.mat[floor(Sb/2),]	
\# graphic presentation	
\# Pivotal points, when distributed according to the percentile	
\# plotting positions of the original data produce a unity line	
obj\<-wblr(unity_TEDF(pivotal_pts, event_vec), col="transparent")	
obj\<-wblr.fit(obj, col="transparent")	
obj\<-wblr.conf(obj, ci=CI, lty="dashed", lwd=1, col="red")	
obj_list[[S+1]]\<-obj	
plot.wblr(obj_list, is.plot.legend=FALSE, 	
xlim=c(.01,20),	
main="Pivotal Analysis of Failure Data with Aribitrary Censoring \\nand 3p
Modeling" )
points(Lower, p2y(dp), type="l", col="blue")	
points(Upper, p2y(dp), type="l", col="blue")
points(Median, p2y(dp), type="l", col="forestgreen")	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
